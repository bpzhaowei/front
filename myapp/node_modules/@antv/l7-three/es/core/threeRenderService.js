import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";

var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;

import { TYPES } from '@antv/l7-core';
import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import { Matrix4, PerspectiveCamera, Scene as ThreeScene, WebGLRenderer } from 'three';
var DEG2RAD = Math.PI / 180;
export var ThreeRenderServiceType = Symbol.for('ThreeJSRenderService');
export var ThreeRenderService = (_dec = injectable(), _dec2 = inject(TYPES.IRendererService), _dec3 = inject(TYPES.IMapService), _dec(_class = (_class2 = function () {
  function ThreeRenderService() {
    _classCallCheck(this, ThreeRenderService);

    _defineProperty(this, "renderer", void 0);

    _defineProperty(this, "camera", void 0);

    _defineProperty(this, "center", void 0);

    _defineProperty(this, "aspect", void 0);

    _defineProperty(this, "update", void 0);

    _defineProperty(this, "scene", void 0);

    _defineProperty(this, "cameraTransform", void 0);

    _initializerDefineProperty(this, "rendererService", _descriptor, this);

    _initializerDefineProperty(this, "mapService", _descriptor2, this);
  }

  _createClass(ThreeRenderService, [{
    key: "init",
    value: function init() {
      var canvas = this.rendererService.getCanvas();
      var gl = this.rendererService.getGLContext();

      if (canvas && gl) {
        var center = this.mapService.getCenter();
        this.center = this.mapService.lngLatToMercator([center.lng, center.lat], 0);
      }

      var _this$center = this.center,
          x = _this$center.x,
          y = _this$center.y,
          z = _this$center.z;
      this.cameraTransform = new Matrix4().makeTranslation(x, y, z);
      this.renderer = new WebGLRenderer({
        canvas: canvas,
        context: gl,
        antialias: true
      });
      this.renderer.autoClear = false;
      this.renderer.gammaFactor = 2.2;
      this.renderer.shadowMap.enabled = true;
      this.scene = new ThreeScene();
      this.aspect = gl.drawingBufferWidth / gl.drawingBufferHeight;
      this.camera = new PerspectiveCamera(45, this.aspect, 1, 20000000);
    }
  }, {
    key: "getRenderCamera",
    value: function getRenderCamera() {
      switch (this.mapService.version) {
        case 'GAODE1.x':
          return this.AMapCamera();

        case 'GAODE2.x':
          return this.AMap2Camera();

        case 'MAPBOX':
          return this.mapboxCamera();

        default:
          return this.AMapCamera();
      }
    }
  }, {
    key: "mapboxCamera",
    value: function mapboxCamera() {
      var mercatorMatrix = new Matrix4().fromArray(this.mapService.map.transform.customLayerMatrix());
      this.camera.projectionMatrix = mercatorMatrix.multiply(this.cameraTransform);
      return this.camera;
    }
  }, {
    key: "AMapCamera",
    value: function AMapCamera() {
      var mapCamera = this.mapService.map.getCameraState();
      var camera = this.camera;
      var pitch = mapCamera.pitch,
          rotation = mapCamera.rotation;
      var fov = mapCamera.fov,
          near = mapCamera.near,
          far = mapCamera.far,
          height = mapCamera.height,
          aspect = mapCamera.aspect;
      pitch *= DEG2RAD;
      rotation *= DEG2RAD;
      camera.fov = 180 * fov / Math.PI;
      camera.aspect = aspect;
      camera.near = near;
      camera.far = far;
      camera.updateProjectionMatrix();
      camera.position.z = height * Math.cos(pitch);
      camera.position.x = height * Math.sin(pitch) * Math.sin(rotation);
      camera.position.y = -height * Math.sin(pitch) * Math.cos(rotation);
      camera.up.x = -Math.cos(pitch) * Math.sin(rotation);
      camera.up.y = Math.cos(pitch) * Math.cos(rotation);
      camera.up.z = Math.sin(pitch);
      camera.lookAt(0, 0, 0);
      camera.position.x += mapCamera.position.x;
      camera.position.y += -mapCamera.position.y;
      return camera;
    }
  }, {
    key: "AMap2Camera",
    value: function AMap2Camera() {
      var _camera$position, _camera$up;

      var customCoords = this.mapService.map.customCoords;
      customCoords.getCenter();
      var camera = this.camera;

      var _customCoords$getCame = customCoords.getCameraParams(),
          near = _customCoords$getCame.near,
          far = _customCoords$getCame.far,
          fov = _customCoords$getCame.fov,
          up = _customCoords$getCame.up,
          lookAt = _customCoords$getCame.lookAt,
          position = _customCoords$getCame.position;

      camera.near = near;
      camera.far = far;
      camera.fov = fov;

      (_camera$position = camera.position).set.apply(_camera$position, _toConsumableArray(position));

      (_camera$up = camera.up).set.apply(_camera$up, _toConsumableArray(up));

      camera.lookAt.apply(camera, _toConsumableArray(lookAt));
      camera.updateProjectionMatrix();
      return camera;
    }
  }]);

  return ThreeRenderService;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "rendererService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "mapService", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
//# sourceMappingURL=threeRenderService.js.map